"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["415989"],{978145:function(e,n,i){e.exports=i.p+"static/image/reactflow-interaction.da01d7ec.gif"},975343:function(e,n,i){e.exports=i.p+"static/image/reactflow-render.48b57f21.gif"},732527:function(e,n,i){e.exports=i.p+"static/image/weaving.422fab53.png"},251440:function(e,n,i){i.r(n),i.d(n,{default:()=>h});var s=i("110239"),r=i("444827"),t=i("732527");let d=i.p+"static/image/ecs.19f1ae29.png";var c=i("975343"),l=i("978145");function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",div:"div",p:"p",img:"img",pre:"pre",code:"code"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"常见问题",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见问题",children:"#"}),"常见问题"]}),"\n",(0,s.jsxs)(n.h2,{id:"为什么不用-reactflow",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么不用-reactflow",children:"#"}),"为什么不用 ReactFlow"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["ReactFlow 不做数据建模，不提供布局算法，只做渲染，开发复杂人力成本依然很高\n见：",(0,s.jsx)(n.a,{href:"https://reactflow.dev/examples/nodes/custom-node",rel:"noopener noreferrer",target:"_blank",children:"https://reactflow.dev/examples/nodes/custom-node"})]}),"\n",(0,s.jsx)(n.li,{children:"ReactFlow的交互的定制成本高，如下，在画布缩放很小时候无法选到点位，也不支持拖拽重连线条"}),"\n"]}),"\n",(0,s.jsx)("table",{children:(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:(0,s.jsx)("img",{src:c})}),(0,s.jsx)("td",{children:(0,s.jsx)("img",{src:l})})]})}),"\n",(0,s.jsxs)(n.h2,{id:"reactflow-付费案例",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactflow-付费案例",children:"#"}),"ReactFlow 付费案例"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"付费功能"}),(0,s.jsx)(n.th,{children:"FlowGramAI 是否支持"}),(0,s.jsx)(n.th,{children:"未来计划支持"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"分组"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"redo/undo"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"copy/paste"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"HelpLines 辅助线"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"自定义节点及形状"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"自定义线条"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"AutoLayout，自动布局整理"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ForceLayout，节点排斥效果"}),(0,s.jsx)(n.td,{children:"不支持"}),(0,s.jsx)(n.td,{children:"No"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Expand/Collapse"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Collaborative 多人协同"}),(0,s.jsx)(n.td,{children:"不支持"}),(0,s.jsx)(n.td,{children:"Yes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"WorkflowBuilder 相当于自动化布局完整案例"}),(0,s.jsx)(n.td,{children:"支持"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsxs)(n.h2,{id:"为什么需要-ioc",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要-ioc",children:"#"}),"为什么需要 IOC"]}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"几个概念："}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"控制反转： Inversion of Control， 是面向对象中的一种设计原则，可以用来降低代码模块之间的耦合度，其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）"}),"\n",(0,s.jsx)(n.li,{children:"领域逻辑：Domain Logic，也可以叫 业务逻辑（Business Logic），这些业务逻辑与特定的产品功能相关"}),"\n",(0,s.jsx)(n.li,{children:"面向切面编程：AOP （Aspect-Oriented Programming），最核心的设计原则是将软件系统拆分为公用逻辑 (横切，有贯穿的意味) 和 领域逻辑 （纵切）的多个个方面 (Aspect)，横切部分可以被所有的 纵切 部分 “按需消费”"}),"\n"]})})]}),"\n",(0,s.jsx)(n.p,{children:"回答这个问题之前先了解切面编程，切面编程目的是将领域逻辑的粒度拆的更细，横切部分可被纵切 “按需消费” ，横切和纵切的连接也叫 织入 (Weaving)，而 IOC 就是扮演 Weaving 注入到纵切的角色"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"切面编程",src:t})}),"\n",(0,s.jsx)(n.p,{children:"理想的切面编程"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",meta:"",children:"- myAppliation 提供业务逻辑\n  - service 特定的业务逻辑服务\n     - customDomainLogicService\n  - contributionImplement 钩子的注册实例化\n    - MyApplicationContributionImpl\n  - component 业务组件\n\n- core 提供通用逻辑\n  - model 通用模型\n  - contribution 钩子接口\n     - LifecycleContribution 应用的生命周期\n     - CommandContribution\n  - service 公用的service的服务\n     - CommandService\n     - ClipboardService\n  - component 公用的组件\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",meta:"",children:"// IOC 的注入\n@injectable()\nexport class CustomDomainLogicService {\n@inject(FlowContextService) protected flowContextService: FlowContextService;\n@inject(CommandService) protected commandService: CommandService;\n@inject(SelectionService) protected selectionService: SelectionService;\n}\n// IOC 的接口声明\ninterface LifecycleContribution {\n onInit(): void\n onStart(): void\n onDispose(): void\n}\n// IOC 的接口实现\n@injectable()\nexport class MyApplicationContributionImpl implement LifecycleContribution {\n  onStart(): void {\n    // 特定的业务逻辑代码\n  }\n}\n\n// 手动挂在到生命周期钩子\nbind(LifecycleContribution).toService(MyApplicationContributionImpl)\n"})}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"IOC是切面编程的一种手段，引入后，底层模块可以以接口形式暴露给外部注册，带来的好处："}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现微内核 + 插件化的设计，实现插件的可插拔按需消费"}),"\n",(0,s.jsx)(n.li,{children:"可以让包拆得更干净，实现 feature 式的拆包"}),"\n"]})})]}),"\n",(0,s.jsxs)(n.h2,{id:"为什么需要-ecs",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要-ecs",children:"#"}),"为什么需要 ECS"]}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"ECS （Entity-Component-System）"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsx)(n.p,{children:"\n适合解耦大的数据对象，常用于游戏，游戏的每个角色（Entity）数据都非常庞大，需要拆分成如物理引擎相关数据、皮肤相关、角色属性等 (多个 Component)，供不同的子系统（System）消费。流程的数据结构复杂，很适合用ECS做拆解"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"ECS",src:d})}),"\n",(0,s.jsx)(n.p,{children:"ReduxStore 伪代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",meta:"pure",children:"const store = () => ({\n  nodes: [{\n    position: any\n    form: any\n    data3: any\n\n  }],\n  edges: []\n})\n\nfunction Playground() {\n  const { nodes } = useStore(store)\n\n  return nodes.map(node => <Node data={node} />)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"优点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"中心化数据管理使用简单"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"缺点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"中心化数据管理无法精确更新，带来性能瓶颈"}),"\n",(0,s.jsx)(n.li,{children:"扩展性差，节点新增一个数据，都耦合到一个 大JSON 里"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ECS 方案\n备注："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"NodeData 对应的是 ECS - Component"}),"\n",(0,s.jsx)(n.li,{children:"Layer 对应 ECS - System"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",meta:"pure",children:"class FlowDocument {\ndataDefines: [\n  NodePositionData,\n  NodeFormData,\n  NodeLineData\n]\nnodeEntities: Entity[] = []\n}\n\n\nclass Entity {\nid: string // 只有id 不带数据\ngetData: (dataId: string) => EntityData\n}\n\n// 渲染线条\nclass LinesLayer {\n@observeEntityData(NodeLineData) lines\nrender() {\n  return lines.map(line => <Line data={line} />)\n}\n}\n\n// 渲染节点位置\nclass NodePositionsLayer {\n@observeEntityData(NodePositionData) positions\nreturn() {\n\n}\n}\n\n// 渲染节点表单\nclass  NodeFormsLayer {\n  @observeEntityData(NodeFormData) contents\nreturn() {}\n}\n\nclass Playground {\nlayers: [\n  LinesLayer, // 线条渲染\n  NodePositionsLayer, // 位置渲染\n  NodeFormsLayer // 内容渲染\n]，\nrender() {\n  return this.layers.map(layer => layer.render())\n}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"优点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"节点数据拆开来单独控制渲染，性能可做到精确更新"}),"\n",(0,s.jsx)(n.li,{children:"扩展性强，新增一个节点数据，则新增一个 XXXData + XXXLayer"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"缺点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"有一定学习成本"}),"\n"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(a,e)})):a(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["zh%2Fguide%2Findex%2Fintroduction.mdx"]={toc:[{id:"为什么不用-reactflow",text:"为什么不用 ReactFlow",depth:2},{id:"reactflow-付费案例",text:"ReactFlow 付费案例",depth:2},{id:"为什么需要-ioc",text:"为什么需要 IOC",depth:2},{id:"为什么需要-ecs",text:"为什么需要 ECS",depth:2}],title:"常见问题",frontmatter:{}}}}]);
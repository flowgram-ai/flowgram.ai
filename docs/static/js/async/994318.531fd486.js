"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["994318"],{576230:function(e,n,t){t.r(n),t.d(n,{default:()=>s});var o=t("110239"),a=t("444827");let i=t.p+"static/image/layer-uml.cd2c8284.jpg";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li",img:"img"},(0,a.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"core-modeling",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#core-modeling",children:"#"}),"Core Modeling"]}),"\n",(0,o.jsx)(n.p,{children:"Playground provides a coordinate system at its foundation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"interface Playground {\n   node: HTMLDivElement // DOM node where canvas is mounted\n   scrollToView({\n     entities?: Entity[] // Specified nodes\n     easing?: boolean // Enable easing\n     bounds?: Reactangle // Scroll to specific bbox position\n    }) // Make canvas scroll smoothly to a specific node and center it\n   toReactComponent() // Render as React node\n   readonly: boolean // Read-only mode\n   config: PlaygroundConfigEntity // Contains canvas data like zoom, scroll etc.\n}\n// Quick access hook\nconst playground = usePlayground()\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"layer",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#layer",children:"#"}),"Layer"]}),"\n",(0,o.jsx)(n.p,{children:":::warning P.S."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The rendering layer establishes its own coordinate system at the bottom layer, implementing simulated scrolling, zooming and other logic based on this coordinate system. When calculating viewport, nodes also need to be transformed to this coordinate system"}),"\n",(0,o.jsx)(n.li,{children:"Rendering is split into multiple layers (Layer) on the canvas. The layered design is based on ECS data splitting concept. Different Layers only listen to the data they want and render independently without interference. Layer can be understood as the System in ECS, which is where Entity data is ultimately consumed"}),"\n",(0,o.jsx)(n.li,{children:"Layer implements observer reactive dynamic dependency collection similar to mobx, data updates will trigger autorun or render\n:::"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Aspect Programming",src:i})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Layer lifecycle"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"interface Layer {\n    /**\n     * Triggered during initialization\n     */\n    onReady?(): void;\n\n    /**\n     * Triggered when playground size changes\n     */\n    onResize?(size: PipelineDimension): void;\n\n    /**\n     * Triggered when playground gains focus\n     */\n    onFocus?(): void;\n\n    /**\n     * Triggered when playground loses focus\n     */\n    onBlur?(): void;\n\n    /**\n     * Listen to zoom changes\n     */\n    onZoom?(scale: number): void;\n\n    /**\n     * Listen to scroll changes\n     */\n    onScroll?(scroll: { scrollX: number; scrollY: number }): void;\n\n    /**\n     * Triggered when viewport updates\n     */\n    onViewportChange?(): void;\n\n    /**\n     * Triggered when readonly or disable state changes\n     * @param state\n     */\n    onReadonlyOrDisabledChange?(state: { disabled: boolean; readonly: boolean }): void;\n\n    /**\n     * Data updates automatically trigger React render, if not provided React rendering won't be called\n     */\n    render?(): JSX.Element\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Layer's positioning is actually similar to Unity game engine's ",(0,o.jsx)(n.a,{href:"https://docs.unity3d.com/ScriptReference/MonoBehaviour.html",rel:"noopener noreferrer",target:"_blank",children:"MonoBehaviour"}),". Unity game engine's script extensions are all based on this, which can be considered the core design, and the underlying implementation is also based on C#'s Reflection dependency injection capability"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C#",meta:"",children:'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class MyMonoBehavior : MonoBehaviour\n{\n    void Awake()\n    {\n        Debug.Log("Awake method is always called before application starts.");\n    }\n    void Start()\n    {\n        Debug.Log("Start method is always called after Awake().");\n    }\n    void Update()\n    {\n        Debug.Log("Update method is called in every frame.");\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Layer's reactive updates"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"export class DemoLayer extends Layer {\n    // Any inversify module injection\n    @inject(FlowDocument) document: FlowDocument\n    // Observe single Entity\n    @observeEntity(SomeEntity) entity: SomeEntity\n    // Observe multiple Entities\n    @observeEntities(SomeEntity) entities: SomeEntity[]\n    // Observe Entity data block (ECS - Component) changes\n    @observeEntityDatas(SomeEntity, SomeEntityData) transforms: SomeEntityData[]\n    autorun() {}\n    render() {\n      return <div></div>\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"flownodeentity",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flownodeentity",children:"#"}),"FlowNodeEntity"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Nodes form a tree. In free canvas mode, nodes are flat without child nodes"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"inteface FlowNodeEntity {\n    id： string\n    children？: FlowNodeEntity[]\n    pre?: FlowNodeEntity\n    next?: FlowNodeEntity\n    parent?: FlowNodeEntity\n    collapsed: boolean // Whether expanded\n    getData(dataRegistry): NodeEntityData\n    addData(dataRegistry)\n}\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"244-flownodetransformdata-nodes-bbox",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#244-flownodetransformdata-nodes-bbox",children:"#"}),"2.4.4 FlowNodeTransformData Node's bbox"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"class FlowNodeTransformData {\n    localTransform: Matrix, // Relative offset, only relative to the previous Sibling node offset in the same Block\n    worldTransform: Matrix, // Absolute offset, relative to the accumulated offset of Parent and Sibling nodes\n    delta：Point // Center/left alignment offset, independent from Matrix, controlled by each node itself\n    getSize(): Size, // Calculated from own (independent node) or child branch node width/height spacing\n    getBounds(): Rectangle // Calculated from worldMatrix and size, used for final rendering, this range can also be used to determine highlight selection area\n    inputPoint(): Point // Input point position, generally the top center position of the first node in Block (centered layout)\n    outputPoint(): Point // Output point position, default is node's bottom center position, but for conditional branches, determined by built-in end node and specific logic\n}\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"flownoderenderdata-node-content-rendering-data",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flownoderenderdata-node-content-rendering-data",children:"#"}),"FlowNodeRenderData Node content rendering data"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"class FlowNodeRenderData {\n  node: HTMLDivElement // Current node's DOM element\n  expanded：boolean // Whether expanded\n  activated： boolean // Whether activated\n  hidden： boolean // Whether hidden\n}\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"flowdocument",children:[(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flowdocument",children:"#"}),"FlowDocument"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",meta:"",children:"interface FLowDocument {\n    root: FlowNodeEntity // Canvas root node\n    fromJSON(data): void // Import data\n    toJSON(): FlowDocumentJSON // Export data\n    addNode(type: string, meta: any): FlowNodeEntity // Add node\n    traveseDFS(fn: (node: flowNodeEntity) => void, startNode = this.root) // Traverse\n}\n"})})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(d,e)})):d(e)}let s=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["en%2Fguide%2Findex%2Fcanvas-engine%2Findex.mdx"]={toc:[{id:"layer",text:"Layer",depth:2},{id:"flownodeentity",text:"FlowNodeEntity",depth:2},{id:"244-flownodetransformdata-nodes-bbox",text:"2.4.4 FlowNodeTransformData Node's bbox",depth:2},{id:"flownoderenderdata-node-content-rendering-data",text:"FlowNodeRenderData Node content rendering data",depth:2},{id:"flowdocument",text:"FlowDocument",depth:2}],title:"Core Modeling",frontmatter:{}}}}]);
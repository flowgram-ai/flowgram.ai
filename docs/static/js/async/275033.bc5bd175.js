"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["275033"],{165268:function(e,n,o){o.r(n),o.d(n,{default:function(){return c}});var t=o(110239),d=o(444827);function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",pre:"pre",code:"code"},(0,d.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"常用-api",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常用-api",children:"#"}),"常用 API"]}),"\n",(0,t.jsxs)(n.h2,{id:"flowdocument-自动化布局文档数据",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flowdocument-自动化布局文档数据",children:"#"}),"FlowDocument （自动化布局文档数据）"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:"",children:"// 通过 hook 获取，也可以通过ctx\nconst doc = useService<FlowDocument>(FlowDocument)\n\ndoc.fromJSON(data) // 加载数据\ndoc.getAllNodes() // 获取所有节点\ndoc.traverseDFS(node => {}) // 深度遍历节点\ndoc.toJSON() // TODO 这里老版本的数据，还没优化，业务最好自己使用 traverseDFS 实现 json 转换\n\ndoc.addFromNode(targetNode, json) // 插入到指定节点的后边\n\ndoc.onNodeCreate(({ node, data}) => {}) // 监听节点创建，data 为创建时候的json数据\ndoc.onNodeDispose(({ node }) => {}) // 监听节点删除\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"workflowdocument-自由连线布局文档数据-继承自-flowdocument",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#workflowdocument-自由连线布局文档数据-继承自-flowdocument",children:"#"}),"WorkflowDocument (自由连线布局文档数据) 继承自 FlowDocument"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:"",children:"const doc = useService<WorkflowDocument>(WorkflowDocument)\n\ndoc.fromJSON(data) // 加载数据\ndoc.toJSON() // 导出数据\ndoc.getAllNodes() // 获取所有节点\ndoc.linesManager.getAllLines() // 获取所有线条\n\n// 创建节点\ndoc.createWorkflowNode({ id: nanoid(), type: 'xxx', data: {}, meta: { position: { x: 0, y: 0 } } })\n// 创建线条，from和to 为对应要连线的节点id， fromPort, toPort 如果为单个端口可以不指定\ndoc.linesManager.createLine({ from, to, fromPort, toPort })\n\n// 监听变化，这里会监听线条和节点等事件\ndoc.onContentChange((e) => {\n\n})\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"flownodeentity节点",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flownodeentity节点",children:"#"}),"FlowNodeEntity（节点）"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:"",children:"node.flowNodeType // 当前节点的type类型\nnode.transform.bounds // 获取节点的外围矩形框, 包含 x,y,width,height\nnode.updateExtInfo({ title: 'xxx' }) // 设置扩展数据, 响应式会刷新节点\nnode.getExtInfo<T>() // 获取扩展数据\nnode.getNodeRegister() // 拿到当前节点的定义\n\nnode.dispose() // 删除节点\n\n// renderData 是 节点 ui相关数据\nconst renderData = node.renderData\nrenderData.node // 当前节点的domNode\nrenderData.expanded // 当前节点是否展开，可以设置\n\n// 拿到所有上游输入和输出节点（自由连线布局）\nnode.getData<WorkflowNodeLinesData>(WorkflowNodeLinesData).allInputNodes\nnode.getData<WorkflowNodeLinesData>(WorkflowNodeLinesData).allOutputNodes\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"playground-画布",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#playground-画布",children:"#"}),"Playground （画布）"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:"",children:"// 通过 hook 获取，也可以通过ctx\nconst playground = useService(Playground)\n\n// 滚动到指定的节点并居中\nctx.playground.config.scrollToView({\n   entities: [node]\n   scrollToCenter： true\n   easing: true // 缓动动画\n})\n\n// 滚动画布\nctx.playground.config.scroll({\n  scrollX: 0\n  scrollY: 0\n})\n\n// 适配屏幕\nctx.playground.config.fitView(\n  doc.root.getData<FlowNodeTransformData>().bounds, // 需要居中的矩形框，这里拿节点根节点的大小代表最大的框\n  true， // 是否缓动\n  20, // padding，留出空白间距\n)\n\n// 缩放\nctx.playground.config.zoomin()\nctx.playground.config.zoomout()\nctx.playground.config.finalScale // 当前缩放比例\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"selectionservice-选择器",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#selectionservice-选择器",children:"#"}),"SelectionService (选择器)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:"",children:"const selectionService = useService<SelectionService>()\n\nselection.selection // 返回当前选中的节点数组，也可以修改，如选中节点 seleciton.selection = [node]\n\nselection.onSelectionChanged(() => {}) // 监听变化\n"})})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(a,e)})):a(e)}let c=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["zh%2Fapi%2Fcommon-apis.mdx"]={toc:[{id:"flowdocument-自动化布局文档数据",text:"FlowDocument （自动化布局文档数据）",depth:2},{id:"workflowdocument-自由连线布局文档数据-继承自-flowdocument",text:"WorkflowDocument (自由连线布局文档数据) 继承自 FlowDocument",depth:2},{id:"flownodeentity节点",text:"FlowNodeEntity（节点）",depth:2},{id:"playground-画布",text:"Playground （画布）",depth:2},{id:"selectionservice-选择器",text:"SelectionService (选择器)",depth:2}],title:"常用 API",frontmatter:{}}}}]);